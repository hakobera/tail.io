#!/usr/bin/env node

var tailio = require('../'),
    program = require('commander'),
    http = require('http'),
    exec = require('child_process').exec,
    sio = require('socket.io'),
    dataSection = require('data-section'),
    ansispan = require('ansispan');

program
  .version(tailio.version)
  .option('-c, --exec <command>', 'set execute command after server start')
  .option('-p, --port <port>', 'set server port number')
  .option('-v, --verbose', 'enable output verbose log to console')
  .option('-n, --lines <K>', 'output the last K lines', "30")
  .parse(process.argv);

var index = dataSection.getSync('index').replace("${MAX_LOG_LINES}", program.lines);

if (program.port) {
  start(program.port);
} else {
  tailio.emptyPort(function(err, port) {
    if (err) {
      abort(err.message);
    }
    start(port);
  });
}

/**
 * Start server and listen stdio.
 * @param {Number} port server port number
 */
function start(port) {
  var server = http.createServer(function(req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.end(index);
  });

  var io = sio.listen(server);
  if (!program.verbose) {
    io.enable('browser client minification');  // send minified client
    io.enable('browser client etag');          // apply etag caching logic based on version number
    io.enable('browser client gzip');          // gzip the file
    io.set('log level', 1);                    // reduce logging
  }
  io.set('transports', ['websocket', 'xhr-polling']);

  var reader = null;
  io.sockets.on('connection', function(socket) {
    if (!reader) {
      reader = new tailio.LineReader();

      reader.on('line', function(line) {
        io.sockets.emit('data', ansispan(line));
      }).on('close', function() {
        console.log('stream end');
      }).on('error', function(err) {
        abort(err.message);
      });
      reader.read(process.stdin);
    }
  });

  server.listen(port, function() {
    console.log('Server listening on http://0.0.0.0:%d', port);
    if (program.exec) {
      var cmd = program.exec + ' http://0.0.0.0:' + port;
      console.log(cmd);
      exec(cmd, function(err, stdout, stderr) {
        if (err) {
          console.log('exec error: %s', err.message);
        }
      });
    }
  });
}

/**
 * Exit with the given `str`.
 *
 * @param {String} str
 */
function abort(str) {
  console.error(str);
  process.exit(1);
}

/* __DATA__
@@ index
<!DOCTYPE html>
<html>
<head>
  <title></title>
  <script src="/socket.io/socket.io.js" type="text/javascript"></script>
  <script>
    window.onload = function() {
      var out = document.getElementById('out');
      var socket = io.connect();
      var logsize = 0;
      var logcapfunc = function(msgs) {
        if (logsize <= ${MAX_LOG_LINES}) {
          return;
        }
        msgs.removeChild(msgs.childNodes.item(0));
        --logsize;
        logcapfunc(msgs);
      }

      socket.on('data', function(data) {
        if (!data) {
           return;
        }

        console.log(data);

        var _doc = document,
            scroll = false;

        if (window.scrollY + _doc.documentElement.clientHeight >= _doc.documentElement.scrollHeight) {
          scroll = true;
        }

        ++logsize;
        logcapfunc(out);

        var div = _doc.createElement('div');
        div.innerHTML = data + '\n';

        while (div.firstChild) {
          out.appendChild(div.firstChild);
        }

        _doc.title = data.replace(/<.*?>/g, '') + ' - tail.io';

        if (scroll) {
          window.scrollTo(0, _doc.body.scrollHeight);
        }
      });
    };
  </script>
</head>
<body>
  <pre id="out"></pre>
</body>
</html>
__DATA__*/
